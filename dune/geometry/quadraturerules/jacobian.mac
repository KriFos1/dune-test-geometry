/*
 * Run `maxima --batch jacobian.mac'.
 */

load(orthopoly)$
load(stringproc)$

fpprec: 100$
maxp: 61$
/* float2bf: false$ */

jacobi(p,a,b) := jacobi_p(p,a,b,x)$

/*
  d/dx jacobi_p
  see http://mathworld.wolfram.com/JacobiPolynomial.html
*/
jacobi_p_x(p,a,b,x) := 1/2*(p+a+b+1)*jacobi_p(p-1,a+1,b+1,x)$

A(n,a,b) := gamma(2*n+a+b+1)/(2^n*n!*gamma(n+a+b+1))$

gamma_n(n,a,b) := 1/(2^(2*n)*(n!)^2)*(2^(2*n+a+b+1)*n!)/(2*n+a+b+1)*(gamma(n+a+1)*gamma(n+b+1))/gamma(n+a+b+1)$

weight(n,a,b,xx) := A(n,a,b)/A(n-1,a,b)*gamma_n(n-1,a,b)/(at(ratexpand(jacobi_p(n-1,a,b,x)*jacobi_p_x(n,a,b,x)), x=xx))$

quad(file, name, alpha, beta, maxp) :=
block([i,N,n_,points,p,w,fd],
fd: openw(file),
printf(fd, "// -*-c++-*-
// WARNING
// This file is automatically generated by jacobian.mac! Don't edit by hand!

#ifndef DUNE_INCLUDING_IMPLEMENTATION
#error This is a private header that should not be included directly.
#error Use #include <dune/geometry/quadraturerules.hh> instead.
#endif
#undef DUNE_INCLUDING_IMPLEMENTATION

namespace Dune {

  // for fundamental types
  template<typename ct>
  void ~aQuadratureInitHelper<ct,true>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {
", name),
for i: 1 thru maxp/2+1 do block([],
  printf(fd,"    // order ~d,~d
    case ~d:
    case ~d:
", 2*i-2,2*i-1, 2*i-2,2*i-1),
  points: makelist(rhs(p), p, bfallroots(jacobi(i,alpha,beta))),
  weights: makelist(bfloat(weight(i, alpha, beta, p)), p, points),
  N: length(points),
  S: sort(makelist(n, n, 1, N), lambda([x,y], weights[x] < weights[y])),
  printf(fd,"      delivered_order = ~d;
",2*i-1),
  printf(fd,"      _points.resize(~d);
",N),
  printf(fd,"      _weight.resize(~d);
",N),
  for n_: 1 thru N do block([n],
    n: S[n_],
    p: points[n],
    printf(fd,"      _points[~d] = ~h;
",n_-1,(p+1)/2),
    printf(fd,"      _weight[~d] = ~h;
",n_-1, weights[n]/2)
  ),
  printf(fd,"      break;

")
),

printf(fd,"    default:
	      DUNE_THROW(QuadratureOrderOutOfRange, \"Quadrature rule \" << p << \" not supported!\");
    }
  }

  // for non-fundamental types: assign numbers as strings
  template<typename ct>
  void ~aQuadratureInitHelper<ct,false>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {
",name),

for i: 1 thru maxp/2+1 do block([],
  printf(fd,"    // order ~d,~d
    case ~d:
    case ~d:
", 2*i-2,2*i-1, 2*i-2,2*i-1),
  points: makelist(rhs(p), p, bfallroots(jacobi(i,alpha,beta))),
  weights: makelist(bfloat(weight(i, alpha, beta, p)), p, points),
  N: length(points),
  S: sort(makelist(n, n, 1, N), lambda([x,y], weights[x] < weights[y])),
  printf(fd,"      delivered_order = ~d;
",2*i-1),
  printf(fd,"      _points.resize(~d);
",N),
  printf(fd,"      _weight.resize(~d);
",N),
  for n_: 1 thru N do block([n],
    n: S[n_],
    p: points[n],
    printf(fd,"      _points[~d] = \"~h\";
",n_-1,(p+1)/2),
    printf(fd,"      _weight[~d] = \"~h\";
",n_-1,weights[n]/2)
  ),
  printf(fd,"      break;

")
),

printf(fd,"    default:
      DUNE_THROW(QuadratureOrderOutOfRange, \"Quadrature rule \" << p << \" not supported!\");
    }
  }

} // namespace
"),
close(fd)
)$

quad("jacobi_1_0_imp.hh", "Jacobi1", 1, 0, maxp);
quad("jacobi_2_0_imp.hh", "Jacobi2", 2, 0, maxp);
quad("cube_imp.hh", "Cube", 0, 0, maxp);

/*
 * Local variables:
 * mode: maxima
 * compile-command: "maxima --batch jacobian.mac"
 * End:
 */
